---
title: "Stats199_Weeks1&2"
author: "Gabriel Fanucchi"
date: "10/8/2019"
header-includes:
  - \usepackage{amsthm}
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Weeks 1-2: Introduction to Dynamical Systems

This project will attempt to introduce nonlinear time series with some background theory from dynamical systems. In the second half of the project, I will explore techniques from topological data analysis (TDA) and then show how they relate to dynamical systems at the end of the project. I will take a more theoretical approach to nonlinear time series that aims to focus on the underlying mathematical theory rather than focusing on nonlinear time series from a statistics background. Furthermore, I will primarily be using code as references to illustrate important concepts. 

For this week's report, I will introduce the theory of dynamical systems and how they relate to nonlinear time series.

First of all, what is the mathematical definition of a time series?

$\textbf{Definition}$: [1]
A $\textit{time series}$ is a sequence $\{y_i\}_{i=0}^\infty$ (from i=0 to n) of real numbers

Alternatively, a time series can be defined as a collection of random variables indexed according to the order they take in time. [2]

For this project, we are concerned with nonlinear time series.

Informally, here is a definition of a nonlinear time series.

$\textbf{Definition}$: [7]
$\textit{Nonlinear time series}$ are generated by nonlinear dynamic equations that display features that cannot be modeled by linear processes, such as: time-changing variance, asymmetric cycles, higher-moment structures, thresholds and breaks.

Nonlinear time series can be described by the rich area of applied mathematics known as dynamical systems. This area of math has its early roots in Henri Poincare in the late 19th Century when he was dealing with the qualitative theory of differential equations and took off when Edward Lorenz discovered the Lorenz attractor. In this project, we will focus on deterministic sytems that are associated with nonlinear time series. However, there are random dynamical systems and systems that produce random nonlinear time series. These will not be the emphasis of this project.

$\textbf{Definition}$: A $\textit{dynamical system}$ is a system that evolves with time over a state space under some rule. 

Dynamical systems can be divided into discrete dynamical systems, which are produced by iterated maps, and continuous dynamical systems which are described by differential equations. 

## Discrete Dynamical Systems - The Logistic Map

A simple example of a discrete dynamical system is the logistic map, given by:

$\dot{x} = rx(1-x)$

Note: The dot above the x indicates a time derivative. So if we want the second derivative of x, then we would denote it like this $\ddot{x}$, and $\dddot{x}$ $\ $ for the third time derivative.

The following code below is sourced from [4]:
```{r}
# logistic map: time and cobweb plots

f.x<- function(x,r){
  r*x*(1-x)
}
##### function to draw the time plot #####
f.temp<-function(xinit,nstep,r){   # starting function f.temp
  xt<- numeric()
  x<- xinit
  xt[1]<- x
  for(i in 2:nstep){
    y<- f.x(x,r)
    x<- y
    xt[i]<- x
  }
  plot(xt,type="b",xlab="time",ylab="x(t)",
       cex.lab=1.7,cex.axis=1.3,lwd=2)
  #xt            # comment to skip iterates
}   # ending function f.temp
##### function to draw the cobweb plot ####
iter<- function(xinit,nstep,r){    # starting function iter
  x<- xinit
  y<- f.x(x,r)
  segments(x,0,x,y,lty=1,lwd=2)
  for(i in 1:nstep){
    points(x,y,pch=19,cex=1.5)
    segments(x,y,y,y,lty=1,lwd=2)
    x<- y
    y<- f.x(x,r)
    segments(x,x,x,y,lty=1,lwd=2)
  }
}    # ending function iter
### parameters and initial conditions
r<- 3.2
#vary r: r<- 2.8,  r<- 3.2,  r<- 3.5,  r<- 4
xinit<- 0.01
nstep<- 25
# nstep<- 25: r=2.8, 3.2; nstep<- 50:  r=3.5, 4
f.temp(xinit,nstep,r)                   # I ask the time plot
### preparation of the cobweb plot
#windows()
plot(1,1,type="n",xlim=c(0,1),ylim=c(0,1),xlab="x(t)",ylab="x(t+1)",
     cex.lab=1.5,cex.axis=1.2)
curve(f.x(x,r),from = 0, to = 1,lty=5,lwd=2,col="black",add=T)  # plot of the function f.x
segments(0,0,1,1,lty=3,lwd=2,col="black")                    # bisector
# more aesthetically: col="blue" and col="magenta"
iter(xinit,nstep,r) 
```

The first picture shows the time series for the logistic map. The second picture shows a cobweb diagram. A cobweb diagram is a visual tool used in dynamical systems to analyze the qualitative behaviour of one-dimensional iterated functions, such as the logistic map. Using a cobweb plot, it is possible to infer the long term status of an initial condition under repeated application of a map.[8]

## Continuous Dynamical Systems

Dynamical systems could also be generated from a system of Ordinary Differential Equations (ODEs). When modeling continuous dynamical systems, we often are interested in finding the attractor which describes the dynamics qualitatively.

$\textbf{Definition}$: [2] An $\textit{attractor}$ is a set which all neighboring trajectories converge. More formally, it is the closed set A with the following properties:

1. A is invariant: any trajectory x(t) that starts in A stays in A for all time.

2. A attracts an open set of initial conditions: there is an open set U containing A such that if x(0) is in U, then the distance from x(t) to A tends to 0 as t goes to infinity.

3. A is minimal: there is no proper subset of A that satisfies conditions 1 and 2.


To expand on condition 2, it means that A attracts all trajectories that start sufficiently close to it. The largest U is called the basin of attraction. [2]

In particular, we are interested in studying strange attractors.

A strange attractor is an attractor that exhibits sensitive dependence on initial conditions. They are strange because the sets are fractal sets. [2]

A "fractal" is the term coined by the French mathematician Benoit Mandelbrot that describes mathematical objects with non-integer dimension. There are also natural fractals like the shape of clouds, thunderbolts, romanesco broccoli, coastlines, and much more. Although there is no widely accepted definition of a fractal, most fractals exhibit self-similarity, which means that you can see the same shape of the fractal if you keep magnifying the fractal at all scales.  Mandelbrot himself defined a fractal as a set where its Hausdorff dimension is strictly less than its topological dimension. A Hausdorff dimension is a type of dimension that characterizes a fractal according to how the fractal exhibits self similarity. They are typically non-integer dimensions. For example, the Koch Snowflake, another famous example of a fractal object, has a Hausdorff dimension of 1.2619. [6]
    
This type of dimension is rigorously studied in a branch of pure mathematics known as measure theory, which is a class typically taken by first-year graduate students in mathematics and statistics. Measure theory goes beyond the scope of this project so we will not explore the details of fractal dimension here.

Sensitive dependence on initial conditions means that changing the initial conditions slightly produces drastically different results in the system we are studying. 

### The Lorenz Attractor

The Lorenz Attractor is also known as the butterfly attractor. Let's construct this attractor and plot its time series. We can also explore this notion of sensitive dependence on initial conditions.

The equations that Edward Lorenz used to discover the Lorenz attractor are as follows:

$$ dx/dt = \sigma(y-x) $$
$$ dy/dt = x(\rho - z) - y$$
$$ dz/dt = xy - \beta z$$

with parameters: $\sigma = 10, \beta = 8/3, \rho = 28$

The following code below is sourced from [4]:
```{r,fig.height=10}
# Code 3.3   lorenz_attractor.R
#
parms<- c(10,8/3,28) # parameters: sigma, beta, rho
tinit<- 0
tfin<- 100
step<- 0.01
times<-seq(tinit,tfin,by=step)
funct<- function(t,integ,parms){  # the system of equations
  x<-integ[1]
  y<-integ[2]
  z<-integ[3]
  sigma<- parms[1]
  beta<- parms[2]
  rho<- parms[3]
  dx<- sigma*(y-x) # that is dx/dt = sigma(y-x)
  dy<- x*(rho-z)-y # that is dy/dt = x(rho-z)-y
  dz<- x*y-beta*z # that is dz/dt = xy -beta z
  list(c(dx,dy,dz))
} # end of funct

require(deSolve)
cinit<-c(1,1,1)
xyz<-lsode(cinit,times,funct,parms)
# xyz # comment if you do not wish the xyz values printed
par(mfrow=c(3,1))
par(mar = c(4.3, 4.8, 1., 3))
par(cex.lab=1.5,cex.axis=1.2,lwd=1,lty=1)
plot(xyz[,1],xyz[,2],type="l",xlab="t",ylab="x(t)",  # x(t) vs t
     xlim=c(tinit,tfin),ylim=c(-30,30))
plot(xyz[,1],xyz[,3],type="l",xlab="t",ylab="y(t)",  # y(t) vs t
     xlim=c(tinit,tfin),ylim=c(-30,30))
plot(xyz[,1],xyz[,4],type="l",xlab="t",ylab="z(t)",  # z(t) vs t
     xlim=c(tinit,tfin),ylim=c(0 ,50))


# phase space portrait
require(scatterplot3d)
scatterplot3d(xyz[,2],xyz[,3],xyz[,4],type="l",xlim=c(-30,30),cex.lab=1.4,cex.axis=1.2) 
```

Changing these parameters creates much different dynamics. The following code below is the same as the above code, I merely changed sigma, beta, and rho.

```{r,fig.height=10}
parms<- c(9,3/8,20) # parameters: sigma, beta, rho
tinit<- 0
tfin<- 100
step<- 0.01
times<-seq(tinit,tfin,by=step)
funct<- function(t,integ,parms){  # the system of equations
  x<-integ[1]
  y<-integ[2]
  z<-integ[3]
  sigma<- parms[1]
  beta<- parms[2]
  rho<- parms[3]
  dx<- sigma*(y-x) # that is dx/dt = sigma(y-x)
  dy<- x*(rho-z)-y # that is dy/dt = x(rho-z)-y
  dz<- x*y-beta*z # that is dz/dt = xy -beta z
  list(c(dx,dy,dz))
} # end of funct

require(deSolve)
cinit<-c(1,1,1)
xyz<-lsode(cinit,times,funct,parms)
# xyz # comment if you do not wish the xyz values printed
par(mfrow=c(3,1))
par(mar = c(4.3, 4.8, 1., 3))
par(cex.lab=1.5,cex.axis=1.2,lwd=1,lty=1)
plot(xyz[,1],xyz[,2],type="l",xlab="t",ylab="x(t)",  # x(t) vs t
     xlim=c(tinit,tfin),ylim=c(-30,30))
plot(xyz[,1],xyz[,3],type="l",xlab="t",ylab="y(t)",  # y(t) vs t
     xlim=c(tinit,tfin),ylim=c(-30,30))
plot(xyz[,1],xyz[,4],type="l",xlab="t",ylab="z(t)",  # z(t) vs t
     xlim=c(tinit,tfin),ylim=c(0 ,50))

# phase space portrait
require(scatterplot3d)
scatterplot3d(xyz[,2],xyz[,3],xyz[,4],type="l",xlim=c(-30,30),cex.lab=1.4,cex.axis=1.2)
```

The dynamics above clearly show an example of "sensitive dependence on initial conditions". The nonlinear time series and the attractor both look much different from the typical dynamics that describe the Lorenz attractor.

### The Rossler Attractor

The Rossler Attractor is another important strange attractor in dynamics. Its equations are the following:

$$dx/dt = -y - z$$
$$dy/dt = x + ay$$
$$dz/dt = b + z(x-c)$$

with parameters: $a = 0.15, b = 0.20, c = 10$
Here is the Rossler Attractor:

The following code below is sourced from [4]:
```{r,fig.height=15}
# Rossler attractor: Complete
library(tseriesChaos)
parms<- c(0.15,0.20,10)  # parameters: a, b, c
tinit<- 0
tfin<- 650
step<- 0.1
times<- seq(tinit,tfin,by=step)
funct<- function(t,integ,parms){
  x<-integ[1]
  y<-integ[2]
  z<-integ[3]
  a<- parms[1]
  b<- parms[2]
  c<- parms[3]
  dx<- -(y+z)                # that is  dx/dt = -(y+z)
  dy<- x+a*y                 # that is  dy/dt = x+ay
  dz<- b+z*(x-c)             # that is  dz/dt = b+z(x-c)
  list(c(dx,dy,dz))
}   # end of funct
require(deSolve)
cinit<-c(0,0,0)
xyz<-lsoda(cinit,times,funct,parms)
#xyz # comment if you do not wish the xyz values printed
par(mfrow=c(3,1))
par(mar = c(6.3, 4.8, 1., 3))
par(cex.lab=2,cex.axis=1.6,lwd=1,lty=1)
plot(xyz[,1],xyz[,2],type="l",xlab="t",ylab="x(t)", # x(t) vs t
     xlim=c(tinit,tfin),ylim=c(-30,30))
plot(xyz[,1],xyz[,3],type="l",xlab="t",ylab="y(t)", # y(t) vs t
     xlim=c(tinit,tfin),ylim=c(-30,30))
plot(xyz[,1],xyz[,4],type="l",xlab="t",ylab="z(t)", # z(t) vs t
     xlim=c(tinit,tfin),ylim=c(0,50))

# phase space portrait
require(scatterplot3d)
scatterplot3d(xyz[,2],xyz[,3],xyz[,4],type="l",xlim=c(-20,20),
              cex.lab=1.4,cex.axis=1.2)
```

Changing the parameters of the Rossler attractor also displays drastically different behavior.

Here are some important observations for the time series produced by the above strange attractors. First of all, the x and y time series are similar but not identical [3]. They oscillate between positive and negative values and we have an irregular shift. Also the trajectories are aperiodic and they will never intersect. Aperiodicity is a property of chaotic systems. [3]

Next week we will explore how to find a strange attractor and reconstruct the dynamics from a time series.